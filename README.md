# Python LBM

## Requirements

 The requirements.txt does not specify any specific versions for any packages.

# Samples

To run the code, one can simply try one of the available samples. The easiest case would be the lid driven cavity in 2D. Provided the root directory is in your PYTHONPATH, simply run:

    python3 sample/lid_driven_cavity_2d.py <optional-output-directory>

Specifying an output directory is optional, a default value exists.
The code will output legacy vtk-files readable by ParaView.
 
# Notes on the code

This code is not written with performance in mind. It uses the AB-pattern, meaning that the particle distribution function (PDF) "f" is defined twice. This will lead to a memory intensive code because one "f" will use up 8 * N * Q bytes of memory using double precision for N number of cells, and using a stencil dDqQ. The equilibrium PDF "f_eq" is also stored at the moment, using up even more memory.

An AA-pattern will only utilize one PDF "f" but requires a more careful implementation of the streaming step. For example: a complete cycle could require two time steps, in one time step a stream-collision-stream action would be taken, and in the other only collision would be required. Provided one store the PDF populations, f_i, correctly.

The code is meant for learning the Lattice Boltzmann Method and using it for simple cases.

The setup is also slow because it uses classes to abstract the entire problem which is inherently slow in Python. There are some crude multi processing implementation because of Pythons inability to pickle objects in the mesh module. The current solution is to write certain data to file and then read the file in multiple cores and processes different blocks of the data before merging the result. This is also memory intensive, especially for a large mesh.
The use of classes in this way is mainly restricted to the mesh module.

Numpy is used to speed up the actual solver using pre-computed streaming maps. Every cell in the mesh is updated independently of all other cells making it ideal for massively parallel computations such as GPUs.

# Code structure

## Core

Core Lattice Boltzmann routines are stored in the core directory.

### lattice

A class storing most of the data, density, velocities, PDF, etc.
The Lattice class make calls to various nb_routines function in order to update its data every time step.

#### Notes on streaming

Streaming is divided into two parts:

- bulk streaming
- boundary streaming

Where the bulk streaming will take action only internal cells, where all neighbours are other cells.

Boundary streaming is used for every cell with at least one neighbouring boundary face. Boundary conditions will store their own info for the streaming step, but only for populations affected by the specific boundary condition.

### stencil

The stencil class should be considered constant and contains all data for a specific stencil of the format dDqQ such as:

    stencil = Stencil(d=2, q=9)  # d2q9
    stencil = Stencil(d=3, q=19) # d3q19

In this code d2q9 and d3q19 is mostly used, but d3q15 and d3q27 should work just as well.

### nb_routines

Routines for the solver are defined in a separate file as simple functions in order for numba to easily JIT (just in time compilation) them.

### Boundary conditions

All boundary conditions are created at run time via a bc_factory, making it easy to create them using an input file such as json.

 - bounce_back: No slip wall or inlet when a velocity and density is defined.
 - anti_bounce_back: Outlet condition.
 - symmetry: Symmetry/Slip condition.
 - orphan: An empty boundary condition, useful for testing in some cases.

Every boundary condition should be registered in the bc_factory.

Great care must be taken where different boundary conditions meet. In this code a priority system is used to decide which boundary condition takes precedence.

## Mesh

A mesh is required for computations. The mesh are made up of elements, where every element is either a face or a cell.

In 2D

 - Faces are are bar elements, with 2 nodes.
 - Cells are hexa elements, with 4 nodes.

In 3D

 - Faces are hexa elements, with 4 nodes.
 - Cells are hexahedron elements, with 8 nodes.

Every cell store a number of neighbours for each cardinal direction, 4 in 2D and 6 in 3D.
Every face store exactly one cell neighbour. Two faces may share the same nodes, but the face normal must point in opposite directions.

The node store geometric coordinates and a list of all elements who shares the node. The purpose of this is for an element to find neighbouring elements.

A mesh can be read from file, currently only the in-house FFA-format is supported.

### Mesh generator

A mesh can be generated by the mesh_generator class. It build 2D or 3D blocks which are then joined. This class will not detect user errors, that is if multiple blocks overlap.

In a 2D case an nx * ny block of cells can be built, with nx and ny cells in the X- and Y-axis respectively. A dictionary input is used to build face elements surrounding the block. A geometric offset can be specified so that multiple blocks do not overlap.

## Util

The utility module contains an exporter class to write legacy vtk-files. It will cache the computational grid on its first run.

A generic factory class is also defined here.

## Simulation

The purpose of the simulation class is to run the LB simulation. It will call various methods of the lattice class to advance one time step. One can discuss whether streaming or collision should come first, but this is not of great interest at this stage.

# Theory

Recommended reading for basic theory is:

- The Lattice Boltzmann Method - Principles and Practice, Timm Kruger.

Chapter 3 give sufficient details regarding the implemented equations and chapter 5 describe boundary conditions.

## Variables descriptions

$$\rho - \text{density}$$
$$u - \text{velocity}$$
$$f_i - \text{discrete velocity distribution function}$$
$$f_i^{eq} - \text{discrete velocity distribution equilibrium function}$$
$$c_s - \text{speed of sound}$$
$$c_i - \text{discrete velocity of population i}$$
$$w_i - \text{weight of population i}$$
$$\tau - \text{Relaxtion time}$$
$$\Delta t - \text{Time step, kepts constant: } \Delta t = 1$$


## Summary of LBM equations

The LBM equations below are implemented in lbm/core/nb_routines, functions:

- density
- velocity
- equilibrium
- collision_bgk
- streaming_bulk
- streaming_boundary

Functions dealing with an external force is of little interest at the moment.

For a stencil dDqQ (dimension D)

$$i = 1,2, ..., Q$$

Implemented stencils are d2q9, d3q15, d3q19, d3q27.

Macroscopic quantities are computed the following way:

$$\rho = \sum{f_i}$$

$$\rho*\vec u = \sum{\vec c_i*f_i}$$

Equlibrium function

$$f_i^{eq} = w_i*\rho*(1 + \frac{\vec u * \vec c_i}{c_s^2} + \frac{(\vec u * \vec c_i)^2}{2*c_s^4} - \frac{\vec u * \vec u}{2*c_s^2})$$

Discretized lattice Boltzmann equation

$$f_i(\vec x+c_i*\Delta t, t + \Delta t) = f_i(\vec x,t) + \Omega_i(\vec x,t)$$

Collision operator (BGK)

$$\Omega(f) = - \frac{f_i - f_i^{eq}}{\tau} * \Delta t$$

Collision step

$$f_i^*(\vec x,t) = f_i(\vec x,t) + \Omega(\vec x, t)$$

Streaming step

$$f_i(\vec x+ \vec c_i*\Delta t, t + \Delta t) = f_i^*(\vec x,t)$$

Boundary condition specific streaming is not specified here, but functions prefixed "boundary_" deal with this.